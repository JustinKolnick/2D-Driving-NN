# 2D-Driving-Neural-Network
This is a 2D Top-Down Neural Network based self-driving car simulation built within Unity.
[![2D-Driving-NN](https://img.youtube.com/vi/QOzqk41eWu0/0.jpg)](https://www.youtube.com/watch?v=QOzqk41eWu0)


## Method and Explanation
This self-learning, self-driving car is built entirely in Unity, a 3-dimensional gaming engine used for many popular games we see today. The project’s functionality is namely within its three main C# scripts: ‘Game Manager’, ‘Neural Network’, and ‘Car’, each acting on elements with respect to their names.
Initially, the Game Manager script sets variables like population size and the neural network neuron count for use within the entire program; for examples sake, I decided to keep the population size small and simple at 10 cars per generation. My algorithm loops through and during its first iteration it creates 10 different neural networks and their respective cars within the game. The weights are randomly set to be values between -0.5 and 0.5 in order to keep a small range of variance within the first generation. Once the generation instance of the ten cars is created, the cars are then propelled by the inner workings of the neural network.
The neural network script sets up each layer with the appropriate number of neurons and weights between layers. Once initialized, the car uses it’s 5 sensors located on the front of the car as the 5 inputs of the neural network. The car script calls upon a smaller sensor script to find the distance between the car and the nearest wall using a ‘RayCast’ method. If the wall is closer than the maximum distance of the sensor, then the sensor should collide with it and return the appropriate distance metric to the car.    

As all of the inputs are returned to the car, the neural network takes over with its feed forward method of producing 2 output neuron values. This is accomplished with a naïve approach by multiplying each weight with the activation of the previous neuron.  I also took advantage of the hyperbolic tangent function to reduce the final 2 neuron output activations to be between -1 and 1. Normally, simple neural networks use values between 0 and 1, but this distinction is to allow the left and right torque to be determined by the negative and positive values respectively.
Once the 2 output neurons have returned their values to the car script, the car then uses these values to appropriately calculate the forward velocity and torque of the car. I shifted the forward velocity neuron’s output 1 unit in the positive direction to give us a valid speed multiplier. The torque output value is simply multiplied by the turn speed and added as torque. 
One of the most vital pieces of the neural network is the fitness function. This fitness function grades each particular input and output configuration given by the created neural networks and allows the network to learn which cars are doing better than others. For my implementation, I decided to stick to a simple checkpoint system. As the cars drive along the track, they hit green checkpoints which add to their overall score. 
The goal of the neural network is to maximize the score gained by the input and output combination of each car. This is done utilizing a genetic algorithm using 2 parents and a few slight mutations. 

Once all the cars are finished, the Game Manager sorts all of the cars by their final fitness value. Sorting a collection of neural networks may seem daunting at first, but this is where the fitness function shines. Within the neural network script, I also implemented a CompareTo method and added IComparable to the class which allows two neural networks to be compared. The method by which they are compared needs to be specified in the method, and in our case, we can simply use the fitness value returned by the final neural network state after the car has stopped.
The 2 highest scoring neural networks then act as parents which are used to create the next generation. I accomplished this using a simple modulus arithmetic that switches back and forth between the weights within the neural networks of the two parents as the weights are copied from the old generation to the new one. 
Once the next generation of neural networks are created from these parents, the offspring are then mutated slightly by random chance. I included a few different mutation techniques including flipping the sign of weights, increasing or decreasing by a random percentage, and choosing a random weight regardless of the parents’ values. 

It is important to recognize the algorithm that goes into stopping the car once it hits a wall. This is to prevent a faulty car from hitting a lot of checkpoints even though its neural network isn’t very strong. To prevent this and stop the car, we must detect once it hits anything with the tag of WALL. Using box colliders and the OnTriggerEnter2D method, I was able to implement this and un-initialize the car once it hits the wall. This was also a vital part of the checkpoint system, as we need to know when the car is passing through a valid checkpoint. This was accomplished in a similar way, but with a boolean array to hold the previous checkpoints to which the car has already visited.
These tags can be set within Unity as an attribute of any game object. They are essential for detecting triggers and collisions such as the one previously described. 
Finally, the algorithm simply repeats this process and slowly but surely converges to a working solution, which again is simply a mélange of weights within the neural network.
